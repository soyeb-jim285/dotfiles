{
  "for": {
    "prefix": "for",
    "body": [
      "for (${1:size_t} ${2:i} = ${3:0}; $2 <${4:length}; $2++) {",
      "\t$0",
      "}"
    ],
    "description": "Code snippet for 'for' loop"
  },
  "forr": {
    "prefix": "forr",
    "body": [
      "for (${1:size_t} ${2:i} = ${3:length} - 1; $2 >= ${4:0}; $2--) {",
      "\t$0",
      "}"
    ],
    "description": "Code snippet for reverse 'for' loop"
  },
  "do": {
    "prefix": "do",
    "body": ["do {", "\t$0", "} while($1);"],
    "description": "Code snippet for do...while loop"
  },
  "while": {
    "prefix": "while",
    "body": ["while ($1) {", "\t$2", "}"],
    "description": ""
  },
  "foreach": {
    "prefix": "foreach",
    "body": [
      "for(${1:auto} ${2:var} : ${3:collection_to_loop}) {",
      "\t$0",
      "}"
    ],
    "description": "Code snippet for range-based for loop (c++11) statement"
  },
  "if": {
    "prefix": "if",
    "body": ["if ($1) {", "\t$0", "}"],
    "description": "Code snippet for if statement"
  },
  "else": {
    "prefix": "else",
    "body": ["else {", "\t$0", "}"],
    "description": "Code snippet for else statement"
  },
  "else if": {
    "prefix": "else if",
    "body": ["else if ($1) {", "\t$0", "}"],
    "description": "Code snippet for else-if statement"
  },
  "enum": {
    "prefix": "enum",
    "body": ["enum ${1:MyEnum} {", "\t$0", "};"],
    "description": "Code snippet for enum"
  },
  "enum class": {
    "prefix": "enum class",
    "body": ["enum class ${1:MyClass} {$0};"],
    "description": "Code snippet for enum class (c++11)"
  },
  "class": {
    "prefix": "class",
    "body": [
      "class ${1:MyClass} {",
      "public:",
      "\t$1();",
      "\t$1($1 &&) = default;",
      "\t$1(const $1 &) = default;",
      "\t$1 &operator=($1 &&) = default;",
      "\t$1 &operator=(const $1 &) = default;",
      "\t~$1();",
      "",
      "private:",
      "\t$2",
      "};",
      "",
      "$1::$1() {",
      "}",
      "",
      "$1::~$1() {",
      "}"
    ],
    "description": "Code snippet for class"
  },
  "eclass": {
    "prefix": "eclass",
    "body": [
      "class ${1:MyClass} {",
      "public:",
      "\t$2",
      "private:",
      "\t$3",
      "};",
      ""
    ],
    "description": "Code snippet for empty class"
  },
  "qclass": {
    "prefix": "qclass",
    "body": [
      "class ${1:MyClass} : public QObject {",
      "\tQ_OBJECT;",
      "public:",
      "\nexplicit $1(QObject *parent = nullptr);",
      "\t$2",
      "signals:",
      "",
      "public slots:",
      "};",
      ""
    ],
    "description": "Code snippet for empty Qt class"
  },
  "classi": {
    "prefix": "classi",
    "body": [
      "class ${1:MyClass} {",
      "public:",
      "\t$1() = default;",
      "\t$1($1 &&) = default;",
      "\t$1(const $1 &) = default;",
      "\t$1 &operator=($1 &&) = default;",
      "\t$1 &operator=(const $1 &) = default;",
      "\t~$1() = default;",
      "",
      "private:",
      "\t$2",
      "};"
    ],
    "description": "Code snippet for class with inline constructor/destructor"
  },
  "interface": {
    "prefix": "interface",
    "body": ["__interface I${1:Interface} {", "\t$0", "};"],
    "description": "Code snippet for interface (Visual C++)"
  },
  "namespace": {
    "prefix": "namespace",
    "body": ["namespace ${1:MyNamespace} {", "\t$0", "}"]
  },
  "#ifdef": {
    "prefix": "#ifdef",
    "body": ["#ifdef ${1:DEBUG}", "$0", "#endif // ${DEBUG}"],
    "description": "Code snippet for #ifdef"
  },
  "#ifndef": {
    "prefix": "#ifndef",
    "body": ["#ifndef ${1:DEBUG}", "$0", "#endif // !$1"],
    "description": "Code snippet for #ifndef"
  },
  "#if": {
    "prefix": "#if",
    "body": ["#if ${1:0}", "$0", "#endif // $1"],
    "description": "Code snippet for #if"
  },
  "struct": {
    "prefix": "struct",
    "body": ["struct ${1:MyStruct} {", "\t$0", "};"],
    "description": "Code snippet for struct"
  },
  "switch": {
    "prefix": "switch",
    "body": [
      "switch (${1:switch_on}) {",
      "\tdefault:",
      "\t\t$0",
      "\t\tbreak;",
      "}"
    ],
    "description": "Code snippet for switch statement"
  },
  "try": {
    "prefix": "try",
    "body": [
      "try {",
      "\t",
      "}",
      "catch (const std::exception&) {",
      "\t$1",
      "}"
    ],
    "description": "Code snippet for try catch"
  },
  "union": {
    "prefix": "union",
    "body": ["union ${1:MyUnion} {", "\t$0", "};"],
    "description": "Code snippet for union"
  },
  "cout": {
    "prefix": "cout",
    "body": ["std::cout << ${1:message};"],
    "description": "Code snippet for printing to std::cout, provided the header is set"
  },
  "cin": {
    "prefix": "cin",
    "body": ["std::cin >> $1;"],
    "description": "Code snippet for std::cin, provided the header is set"
  },
  "printf": {
    "prefix": "printf",
    "body": ["printf(\"$1\\n\"$0);"],
    "description": "Generic printf() snippet"
  },
  "sprintf": {
    "prefix": "sprintf",
    "body": ["sprintf($1, \"$2\\n\"$0);"],
    "description": "Generic sprintf() snippet"
  },
  "fprintf": {
    "prefix": "fprintf",
    "body": ["fprintf(${1:stderr}, \"$2\\n\"$0);"],
    "description": "Generic fprintf() snippet"
  },
  "scanf": {
    "prefix": "scanf",
    "body": ["scanf(\"$1\"$0);"],
    "description": "Generic scanf() snippet"
  },
  "sscanf": {
    "prefix": "sscanf",
    "body": ["sscanf($1, \"$2\"$0);"],
    "description": "Generic sscanf() snippet"
  },
  "fscanf": {
    "prefix": "fscanf",
    "body": ["fscanf($1, \"$2\"$0);"],
    "description": "Generic fscanf() snippet"
  },
  "#inc": {
    "prefix": "#inc",
    "body": ["#include \"$0\""],
    "description": "Code snippet for #include \" \""
  },
  "#inc<": {
    "prefix": "#inc<",
    "body": ["#include <$0>"],
    "description": "Code snippet for #include < >"
  },
  "#def": {
    "prefix": "def",
    "body": ["#define $0"],
    "description": "Code snippet for #define \" \""
  },
  "Main function template": {
    "prefix": "main",
    "body": ["int main (int argc, char *argv[]) {", "\t$1", "\treturn 0;", "}"],
    "description": "A standard main function for a C++ program"
  },
  "ordered_set": {
    "prefix": "orset",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>",
      "#define ordered_pair_set tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update>"
    ]
  },
  "Template": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define rep(i, a, b) for (int i = a; i < (b); ++i)",
      "#define all(x) begin(x), end(x)",
      "#define sz(x) (int)(x).size()",
      "typedef long long ll;",
      "typedef pair<int, int> pii;",
      "typedef vector<int> vi;",
      "",
      "void solve() {$0}",
      "int main() {",
      "  cin.tie(0)->sync_with_stdio(0);",
      "  cin.exceptions(cin.failbit);",
      "  int t = 1;",
      "  cin >> t;",
      "  while (t--) {",
      "    solve();",
      "  }",
      "#ifdef ONPC",
      "  cerr << endl",
      "       << \"finished in \" << clock() * 1.0 / CLOCKS_PER_SEC << \" sec\" << endl;",
      "#endif",
      "}",
      ""
    ],
    "description": "Template"
  },
  "binary_exponents": {
    "prefix": "binpow",
    "body": [
      "ll binpow(ll a, ll b)",
      "{",
      "\tll res = 1;",
      "\twhile (b > 0)",
      "\t{",
      "\t\tif (b & 1)",
      "\t\t\tres *= a;",
      "\t\ta *= a;",
      "\t\tb >>= 1;",
      "\t}",
      "\treturn res;",
      "}"
    ]
  },
  "binary_exponents_mod": {
    "prefix": "binpowmod",
    "body": [
      "ll binpowmod(ll a, ll b, ll m)",
      "{",
      "\tll res = 1;",
      "\twhile (b > 0)",
      "\t{",
      "\t\tif (b & 1)",
      "\t\t{",
      "\t\t\tres *= a;",
      "\t\t\tres = res % m;",
      "\t\t}",
      "\t\ta *= a;",
      "\t\ta = a%m;",
      "\t\tb >>= 1;",
      "\t}",
      "\treturn res;",
      "}"
    ]
  },
  "Extended gcd": {
    "prefix": "extgcd",
    "body": [
      "ll gcd(ll a, ll b, ll &x, ll &y)",
      "{",
      "\tif (b == 0)",
      "\t{",
      "\t\tx = 1;",
      "\t\ty = 0;",
      "\t\treturn a;",
      "\t}",
      "\tll x1, y1;",
      "\tll d = gcd(b, a % b, x1, y1);",
      "\tx = y1;",
      "\ty = x1 - y1 * (a / b);",
      "\treturn d;",
      "}"
    ]
  },
  "num_len": {
    "prefix": "numlen",
    "body": [
      "ll num_len(ll n)",
      "{",
      "\tll d = 0;",
      "\twhile(n>0)",
      "\t{",
      "\t\td++;",
      "\t\tn/=10;",
      "\t}",
      "\treturn d;",
      "}"
    ]
  },
  "Segment Stree": {
    "prefix": "st",
    "body": [
      "struct Tree {",
      "	typedef int T;",
      "	static constexpr T unit = INT_MIN;",
      "	T f(T a, T b) { return max(a, b); } // (any associative fn)",
      "	vector<T> s; int n;",
      "	Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}",
      "	void update(int pos, T val) {",
      "		for (s[pos += n] = val; pos /= 2;)",
      "			s[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
      "	}",
      "	T query(int b, int e) { // query [b, e)",
      "		T ra = unit, rb = unit;",
      "		for (b += n, e += n; b < e; b /= 2, e /= 2) {",
      "			if (b % 2) ra = f(ra, s[b++]);",
      "			if (e % 2) rb = f(s[--e], rb);",
      "		}",
      "		return f(ra, rb);",
      "	}",
      "};",
      ""
    ],
    "description": "Segment Stree"
  },
  "segtree_lazy": {
    "prefix": "lazy",
    "body": [
      "const int N = ${1:1e5} + 9;",
      "int a[N];",
      "struct segment_tree {",
      "#define lc (n << 1)",
      "#define rc ((n << 1) | 1)",
      "  long long t[4 * N], lazy[4 * N];",
      "  segment_tree() {",
      "\tmemset(t, 0, sizeof t);",
      "\tmemset(lazy, 0, sizeof lazy);",
      "  }",
      "  inline void push(int n, int b, int e) {",
      "\tif (lazy[n] == 0)",
      "\t  return;",
      "\tt[n] = t[n] + lazy[n] * (e - b + 1);",
      "\tif (b != e) {",
      "\t  lazy[lc] = lazy[lc] + lazy[n];",
      "\t  lazy[rc] = lazy[rc] + lazy[n];",
      "\t}",
      "\tlazy[n] = 0;",
      "  }",
      "  inline long long combine(long long a, long long b) { return ${2:a + b}; }",
      "  inline void pull(int n) { t[n] = ${3:t[lc] + t[rc]}; }",
      "  void build(int n, int b, int e) {",
      "\tlazy[n] = 0;",
      "\tif (b == e) {",
      "\t  t[n] = a[b];",
      "\t  return;",
      "\t}",
      "\tint mid = (b + e) >> 1;",
      "\tbuild(lc, b, mid);",
      "\tbuild(rc, mid + 1, e);",
      "\tpull(n);",
      "  }",
      "  void upd(int n, int b, int e, int i, int j, long long v) {",
      "\tpush(n, b, e);",
      "\tif (j < b || e < i)",
      "\t  return;",
      "\tif (i <= b && e <= j) {",
      "\t  lazy[n] = v; // set lazy",
      "\t  push(n, b, e);",
      "\t  return;",
      "\t}",
      "\tint mid = (b + e) >> 1;",
      "\tupd(lc, b, mid, i, j, v);",
      "\tupd(rc, mid + 1, e, i, j, v);",
      "\tpull(n);",
      "  }",
      "  long long query(int n, int b, int e, int i, int j) {",
      "\tpush(n, b, e);",
      "\tif (i > e || b > j)",
      "\t  return 0; // return null",
      "\tif (i <= b && e <= j)",
      "\t  return t[n];",
      "\tint mid = (b + e) >> 1;",
      "\treturn combine(query(lc, b, mid, i, j), query(rc, mid + 1, e, i, j));",
      "  }",
      "};"
    ],
    "description": "Segment tree with lazy propagation."
  },
  "Fenwick Tree": {
    "prefix": "ft",
    "body": [
      "struct FT {",
      "	vector<ll> s;",
      "	FT(int n) : s(n) {}",
      "	void update(int pos, ll dif) { // a[pos] += dif",
      "		for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;",
      "	}",
      "  void upd(int l, int r, ll dif) {",
      "    update(l, dif);",
      "    update(r + 1, -dif);",
      "  }",
      "	ll query(int pos) { // sum of values in [0, pos)",
      "		ll res = 0;",
      "		for (; pos > 0; pos &= pos - 1) res += s[pos-1];",
      "		return res;",
      "	}",
      "	int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum",
      "		// Returns n if no sum is >= sum, or -1 if empty sum is.",
      "		if (sum <= 0) return -1;",
      "		int pos = 0;",
      "		for (int pw = 1 << 25; pw; pw >>= 1) {",
      "			if (pos + pw <= sz(s) && s[pos + pw-1] < sum)",
      "				pos += pw, sum -= s[pos-1];",
      "		}",
      "		return pos;",
      "	}",
      "};",
      ""
    ],
    "description": "Fenwick Tree"
  },
  "Fenwick Tree2": {
    "prefix": "ft2",
    "body": [
      "struct FT2 {",
      "	vector<vi> ys; vector<FT> ft;",
      "	FT2(int limx) : ys(limx) {}",
      "	void fakeUpdate(int x, int y) {",
      "		for (; x < sz(ys); x |= x + 1) ys[x].push_back(y);",
      "	}",
      "	void init() {",
      "		for (vi& v : ys) sort(all(v)), ft.emplace_back(sz(v));",
      "	}",
      "	int ind(int x, int y) {",
      "		return (int)(lower_bound(all(ys[x]), y) - ys[x].begin()); }",
      "	void update(int x, int y, ll dif) {",
      "		for (; x < sz(ys); x |= x + 1)",
      "			ft[x].update(ind(x, y), dif);",
      "	}",
      "	ll query(int x, int y) {",
      "		ll sum = 0;",
      "		for (; x; x &= x - 1)",
      "			sum += ft[x-1].query(ind(x-1, y));",
      "		return sum;",
      "	}",
      "};",
      ""
    ],
    "description": "Computes sums a[i,j] for all i<I, j<J, and increases single elements a[i,j]. Requires that the elements to be updated are known in advance (call fakeUpdate() before init())"
  },
  "sparse table": {
    "prefix": "spt",
    "body": [
      "template <typename T> struct SparseTable {",
      "  vector<vector<T>> st;",
      "  vector<int> log;",
      "  SparseTable(int n) {",
      "    int maxLog = log2(n) + 1;",
      "    st.assign(n, vector<T>(maxLog));",
      "    log.assign(n + 1, 0);",
      "    for (int i = 2; i <= n; i++) {",
      "      log[i] = log[i / 2] + 1;",
      "    }",
      "  }",
      "  void build(vector<T> &arr) {",
      "    int n = arr.size();",
      "    int maxLog = log2(n) + 1;",
      "    for (int i = 0; i < n; i++) {",
      "      st[i][0] = arr[i];",
      "    }",
      "    for (int j = 1; (1 << j) <= n; j++) {",
      "      for (int i = 0; i + (1 << j) <= n; i++) {",
      "        st[i][j] = fn(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
      "      }",
      "    }",
      "  }",
      "  inline T fn(T a, T b) { return __gcd(a, b); }",
      "  inline T query(int L, int R) {",
      "    if (R < L)",
      "      return -2e9;",
      "    int j = log[R - L + 1];",
      "    return fn(st[L][j], st[R - (1 << j) + 1][j]);",
      "  }",
      "};",
      ""
    ],
    "description": "sparse table"
  },
  "Treap": {
    "prefix": "treap",
    "body": [
      "struct Node {",
      "	Node *l = 0, *r = 0;",
      "	int val, y, c = 1;",
      "	Node(int val) : val(val), y(rand()) {}",
      "	void recalc();",
      "};",
      "int cnt(Node* n) { return n ? n->c : 0; }",
      "void Node::recalc() { c = cnt(l) + cnt(r) + 1; }",
      "template<class F> void each(Node* n, F f) {",
      "	if (n) { each(n->l, f); f(n->val); each(n->r, f); }",
      "}",
      "pair<Node*, Node*> split(Node* n, int k) {",
      "	if (!n) return {};",
      "	if (cnt(n->l) >= k) { // \"n->val >= k\" for lower_bound(k)",
      "		auto pa = split(n->l, k);",
      "		n->l = pa.second;",
      "		n->recalc();",
      "		return {pa.first, n};",
      "	} else {",
      "		auto pa = split(n->r, k - cnt(n->l) - 1); // and just \"k\"",
      "		n->r = pa.first;",
      "		n->recalc();",
      "		return {n, pa.second};",
      "	}",
      "}",
      "Node* merge(Node* l, Node* r) {",
      "	if (!l) return r;",
      "	if (!r) return l;",
      "	if (l->y > r->y) {",
      "		l->r = merge(l->r, r);",
      "		l->recalc();",
      "		return l;",
      "	} else {",
      "		r->l = merge(l, r->l);",
      "		r->recalc();",
      "		return r;",
      "	}",
      "}",
      "Node* ins(Node* t, Node* n, int pos) {",
      "	auto pa = split(t, pos);",
      "	return merge(merge(pa.first, n), pa.second);",
      "}",
      "// Example application: move the range [l, r) to index k",
      "void move(Node*& t, int l, int r, int k) {",
      "	Node *a, *b, *c;",
      "	tie(a,b) = split(t, l); tie(b,c) = split(b, r - l);",
      "	if (k <= l) t = merge(ins(a, b, k), c);",
      "	else t = merge(a, ins(c, b, k - r));",
      "}",
      ""
    ],
    "description": "Treap"
  },
  "DSU": {
    "prefix": "dsu",
    "body": [
      "struct UF {",
      "	vi e;",
      "	UF(int n) : e(n, -1) {}",
      "	bool sameSet(int a, int b) { return find(a) == find(b); }",
      "	int size(int x) { return -e[find(x)]; }",
      "	int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
      "	bool join(int a, int b) {",
      "		a = find(a), b = find(b);",
      "		if (a == b) return false;",
      "		if (e[a] > e[b]) swap(a, b);",
      "		e[a] += e[b]; e[b] = a;",
      "		return true;",
      "	}",
      "};",
      ""
    ],
    "description": "DSU"
  },
  "3d_Convex_Hall": {
    "prefix": "hall3d",
    "body": [
      "typedef Point3D<double> P3;",
      "",
      "struct PR {",
      "	void ins(int x) { (a == -1 ? a : b) = x; }",
      "	void rem(int x) { (a == x ? a : b) = -1; }",
      "	int cnt() { return (a != -1) + (b != -1); }",
      "	int a, b;",
      "};",
      "",
      "struct F { P3 q; int a, b, c; };",
      "",
      "vector<F> hull3d(const vector<P3>& A) {",
      "	assert(sz(A) >= 4);",
      "	vector<vector<PR>> E(sz(A), vector<PR>(sz(A), {-1, -1}));",
      "#define E(x,y) E[f.x][f.y]",
      "	vector<F> FS;",
      "	auto mf = [&](int i, int j, int k, int l) {",
      "		P3 q = (A[j] - A[i]).cross((A[k] - A[i]));",
      "		if (q.dot(A[l]) > q.dot(A[i]))",
      "			q = q * -1;",
      "		F f{q, i, j, k};",
      "		E(a,b).ins(k); E(a,c).ins(j); E(b,c).ins(i);",
      "		FS.push_back(f);",
      "	};",
      "	rep(i,0,4) rep(j,i+1,4) rep(k,j+1,4)",
      "		mf(i, j, k, 6 - i - j - k);",
      "",
      "	rep(i,4,sz(A)) {",
      "		rep(j,0,sz(FS)) {",
      "			F f = FS[j];",
      "			if(f.q.dot(A[i]) > f.q.dot(A[f.a])) {",
      "				E(a,b).rem(f.c);",
      "				E(a,c).rem(f.b);",
      "				E(b,c).rem(f.a);",
      "				swap(FS[j--], FS.back());",
      "				FS.pop_back();",
      "			}",
      "		}",
      "		int nw = sz(FS);",
      "		rep(j,0,nw) {",
      "			F f = FS[j];",
      "#define C(a, b, c) if (E(a,b).cnt() != 2) mf(f.a, f.b, i, f.c);",
      "			C(a, b, c); C(a, c, b); C(b, c, a);",
      "		}",
      "	}",
      "	for (F& it : FS) if ((A[it.b] - A[it.a]).cross(",
      "		A[it.c] - A[it.a]).dot(it.q) <= 0) swap(it.c, it.b);",
      "	return FS;",
      "};",
      ""
    ],
    "description": "3d_Convex_Hall"
  },
  "Angle": {
    "prefix": "angle",
    "body": [
      "struct Angle {",
      "	int x, y;",
      "	int t;",
      "	Angle(int x, int y, int t=0) : x(x), y(y), t(t) {}",
      "	Angle operator-(Angle b) const { return {x-b.x, y-b.y, t}; }",
      "	int half() const {",
      "		assert(x || y);",
      "		return y < 0 || (y == 0 && x < 0);",
      "	}",
      "	Angle t90() const { return {-y, x, t + (half() && x >= 0)}; }",
      "	Angle t180() const { return {-x, -y, t + half()}; }",
      "	Angle t360() const { return {x, y, t + 1}; }",
      "};",
      "bool operator<(Angle a, Angle b) {",
      "	// add a.dist2() and b.dist2() to also compare distances",
      "	return make_tuple(a.t, a.half(), a.y * (ll)b.x) <",
      "	       make_tuple(b.t, b.half(), a.x * (ll)b.y);",
      "}",
      "",
      "// Given two points, this calculates the smallest angle between",
      "// them, i.e., the angle that covers the defined line segment.",
      "pair<Angle, Angle> segmentAngles(Angle a, Angle b) {",
      "	if (b < a) swap(a, b);",
      "	return (b < a.t180() ?",
      "	        make_pair(a, b) : make_pair(b, a.t360()));",
      "}",
      "Angle operator+(Angle a, Angle b) { // point a + vector b",
      "	Angle r(a.x + b.x, a.y + b.y, a.t);",
      "	if (a.t180() < r) r.t--;",
      "	return r.t180() < a ? r.t360() : r;",
      "}",
      "Angle angleDiff(Angle a, Angle b) { // angle b - angle a",
      "	int tu = b.t - a.t; a.t = b.t;",
      "	return {a.x*b.x + a.y*b.y, a.x*b.y - a.y*b.x, tu - (b < a)};",
      "}",
      ""
    ],
    "description": "Angle"
  },
  "Circle_Intesection": {
    "prefix": "circint",
    "body": [
      "typedef Point<double> P;",
      "bool circleInter(P a,P b,double r1,double r2,pair<P, P>* out) {",
      "	if (a == b) { assert(r1 != r2); return false; }",
      "	P vec = b - a;",
      "	double d2 = vec.dist2(), sum = r1+r2, dif = r1-r2,",
      "	       p = (d2 + r1*r1 - r2*r2)/(d2*2), h2 = r1*r1 - p*p*d2;",
      "	if (sum*sum < d2 || dif*dif > d2) return false;",
      "	P mid = a + vec*p, per = vec.perp() * sqrt(fmax(0, h2) / d2);",
      "	*out = {mid + per, mid - per};",
      "	return true;",
      "}",
      ""
    ],
    "description": "Circle_Intesection"
  },
  "Circle_Line_Intesection": {
    "prefix": "circlint",
    "body": [
      "template<class P>",
      "vector<P> circleLine(P c, double r, P a, P b) {",
      "	P ab = b - a, p = a + ab * (c-a).dot(ab) / ab.dist2();",
      "	double s = a.cross(b, c), h2 = r*r - s*s / ab.dist2();",
      "	if (h2 < 0) return {};",
      "	if (h2 == 0) return {p};",
      "	P h = ab.unit() * sqrt(h2);",
      "	return {p - h, p + h};",
      "}",
      ""
    ],
    "description": "Circle_Line_Intesection"
  },
  "ConvexHall": {
    "prefix": "hall",
    "body": [
      "typedef Point<ll> P;",
      "vector<P> convexHull(vector<P> pts, bool strict = true) {",
      "  if (sz(pts) <= 1)",
      "    return pts;",
      "  sort(all(pts));",
      "  vector<P> h(sz(pts) + 1);",
      "  int s = 0, t = 0;",
      "  for (int it = 2; it--; s = --t, reverse(all(pts))) {",
      "    for (P p : pts) {",
      "      while (t >= s + 2 && (strict ? h[t - 2].cross(h[t - 1], p) < 0",
      "                                   : h[t - 2].cross(h[t - 1], p) <= 0)) {",
      "        t--;",
      "      }",
      "      h[t++] = p;",
      "    }",
      "  }",
      "  return {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};",
      "}",
      ""
    ],
    "description": "ConvexHall"
  },
  "Delaunay triangulation": {
    "prefix": "delaunay",
    "body": [
      "typedef Point<ll> P;",
      "typedef struct Quad* Q;",
      "typedef __int128_t lll; // (can be ll if coords are < 2e4)",
      "P arb(LLONG_MAX,LLONG_MAX); // not equal to any other point",
      "",
      "struct Quad {",
      "	Q rot, o; P p = arb; bool mark;",
      "	P& F() { return r()->p; }",
      "	Q& r() { return rot->rot; }",
      "	Q prev() { return rot->o->rot; }",
      "	Q next() { return r()->prev(); }",
      "} *H;",
      "",
      "bool circ(P p, P a, P b, P c) { // is p in the circumcircle?",
      "	lll p2 = p.dist2(), A = a.dist2()-p2,",
      "	    B = b.dist2()-p2, C = c.dist2()-p2;",
      "	return p.cross(a,b)*C + p.cross(b,c)*A + p.cross(c,a)*B > 0;",
      "}",
      "Q makeEdge(P orig, P dest) {",
      "	Q r = H ? H : new Quad{new Quad{new Quad{new Quad{0}}}};",
      "	H = r->o; r->r()->r() = r;",
      "	rep(i,0,4) r = r->rot, r->p = arb, r->o = i & 1 ? r : r->r();",
      "	r->p = orig; r->F() = dest;",
      "	return r;",
      "}",
      "void splice(Q a, Q b) {",
      "	swap(a->o->rot->o, b->o->rot->o); swap(a->o, b->o);",
      "}",
      "Q connect(Q a, Q b) {",
      "	Q q = makeEdge(a->F(), b->p);",
      "	splice(q, a->next());",
      "	splice(q->r(), b);",
      "	return q;",
      "}",
      "",
      "pair<Q,Q> rec(const vector<P>& s) {",
      "	if (sz(s) <= 3) {",
      "		Q a = makeEdge(s[0], s[1]), b = makeEdge(s[1], s.back());",
      "		if (sz(s) == 2) return { a, a->r() };",
      "		splice(a->r(), b);",
      "		auto side = s[0].cross(s[1], s[2]);",
      "		Q c = side ? connect(b, a) : 0;",
      "		return {side < 0 ? c->r() : a, side < 0 ? c : b->r() };",
      "	}",
      "",
      "#define H(e) e->F(), e->p",
      "#define valid(e) (e->F().cross(H(base)) > 0)",
      "	Q A, B, ra, rb;",
      "	int half = sz(s) / 2;",
      "	tie(ra, A) = rec({all(s) - half});",
      "	tie(B, rb) = rec({sz(s) - half + all(s)});",
      "	while ((B->p.cross(H(A)) < 0 && (A = A->next())) ||",
      "	       (A->p.cross(H(B)) > 0 && (B = B->r()->o)));",
      "	Q base = connect(B->r(), A);",
      "	if (A->p == ra->p) ra = base->r();",
      "	if (B->p == rb->p) rb = base;",
      "",
      "#define DEL(e, init, dir) Q e = init->dir; if (valid(e)) \\",
      "		while (circ(e->dir->F(), H(base), e->F())) { \\",
      "			Q t = e->dir; \\",
      "			splice(e, e->prev()); \\",
      "			splice(e->r(), e->r()->prev()); \\",
      "			e->o = H; H = e; e = t; \\",
      "		}",
      "	for (;;) {",
      "		DEL(LC, base->r(), o);  DEL(RC, base, prev());",
      "		if (!valid(LC) && !valid(RC)) break;",
      "		if (!valid(LC) || (valid(RC) && circ(H(RC), H(LC))))",
      "			base = connect(RC, base->r());",
      "		else",
      "			base = connect(base->r(), LC->r());",
      "	}",
      "	return { ra, rb };",
      "}",
      "",
      "vector<P> triangulate(vector<P> pts) {",
      "	sort(all(pts));  assert(unique(all(pts)) == pts.end());",
      "	if (sz(pts) < 2) return {};",
      "	Q e = rec(pts).first;",
      "	vector<Q> q = {e};",
      "	int qi = 0;",
      "	while (e->o->F().cross(e->F(), e->p) < 0) e = e->o;",
      "#define ADD { Q c = e; do { c->mark = 1; pts.push_back(c->p); \\",
      "	q.push_back(c->r()); c = c->next(); } while (c != e); }",
      "	ADD; pts.clear();",
      "	while (qi < sz(q)) if (!(e = q[qi++])->mark) ADD;",
      "	return pts;",
      "}",
      ""
    ],
    "description": "Delaunay triangulation"
  },
  "HallDiameter": {
    "prefix": "halldiameter",
    "body": [
      "typedef Point<ll> P;",
      "array<P, 2> hullDiameter(vector<P> S) {",
      "	int n = sz(S), j = n < 2 ? 0 : 1;",
      "	pair<ll, array<P, 2>> res({0, {S[0], S[0]}});",
      "	rep(i,0,j)",
      "		for (;; j = (j + 1) % n) {",
      "			res = max(res, {(S[i] - S[j]).dist2(), {S[i], S[j]}});",
      "			if ((S[(j + 1) % n] - S[j]).cross(S[i + 1] - S[i]) >= 0)",
      "				break;",
      "		}",
      "	return res.second;",
      "}",
      ""
    ],
    "description": "HallDiameter"
  },
  "Minkowskisum": {
    "prefix": "minkowski",
    "body": [
      "void reorder_polygon(vector<pt> & P){",
      "    size_t pos = 0;",
      "    for(size_t i = 1; i < P.size(); i++){",
      "        if(P[i].y < P[pos].y || (P[i].y == P[pos].y && P[i].x < P[pos].x))",
      "            pos = i;",
      "    }",
      "    rotate(P.begin(), P.begin() + pos, P.end());",
      "}",
      "",
      "vector<pt> minkowski(vector<pt> P, vector<pt> Q){",
      "    reorder_polygon(P); reorder_polygon(Q);",
      "    P.push_back(P[0]); P.push_back(P[1]);",
      "    Q.push_back(Q[0]); Q.push_back(Q[1]);",
      "    vector<pt> ret;",
      "    size_t i = 0, j = 0;",
      "    while(i < P.size() - 2 || j < Q.size() - 2){",
      "        ret.push_back(P[i] + Q[j]);",
      "        auto cross = (P[i + 1] - P[i]).cross(Q[j + 1] - Q[j]);",
      "        i += cross >= 0 && i < P.size() - 2;",
      "        j += cross <= 0 && j < Q.size() - 2;",
      "    }",
      "    return ret;",
      "}",
      ""
    ],
    "description": "Minkowskisum"
  },
  "OnSegment": {
    "prefix": "onsegment",
    "body": [
      "template<class P> bool onSegment(P s, P e, P p) {",
      "	return p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;",
      "}",
      ""
    ],
    "description": "OnSegment"
  },
  "Point": {
    "prefix": "pt",
    "body": [
      "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
      "template<class T>",
      "struct Point {",
      "	typedef Point P;",
      "	T x, y;",
      "	explicit Point(T x=0, T y=0) : x(x), y(y) {}",
      "	bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }",
      "	bool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }",
      "	P operator+(P p) const { return P(x+p.x, y+p.y); }",
      "	P operator-(P p) const { return P(x-p.x, y-p.y); }",
      "	P operator*(T d) const { return P(x*d, y*d); }",
      "	P operator/(T d) const { return P(x/d, y/d); }",
      "	T dot(P p) const { return x*p.x + y*p.y; }",
      "	T cross(P p) const { return x*p.y - y*p.x; }",
      "	T cross(P a, P b) const { return (a-*this).cross(b-*this); }",
      "	T dist2() const { return x*x + y*y; }",
      "	double dist() const { return sqrt((double)dist2()); }",
      "	// angle to x-axis in interval [-pi, pi]",
      "	double angle() const { return atan2(y, x); }",
      "	P unit() const { return *this/dist(); } // makes dist()=1",
      "	P perp() const { return P(-y, x); } // rotates +90 degrees",
      "	P normal() const { return perp().unit(); }",
      "	// returns point rotated 'a' radians ccw around the origin",
      "	P rotate(double a) const {",
      "		return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }",
      "	friend ostream& operator<<(ostream& os, P p) {",
      "		return os << \"(\" << p.x << \",\" << p.y << \")\"; }",
      "};",
      ""
    ],
    "description": "Point"
  },
  "Point3D": {
    "prefix": "pt3",
    "body": [
      "template<class T> struct Point3D {",
      "	typedef Point3D P;",
      "	typedef const P& R;",
      "	T x, y, z;",
      "	explicit Point3D(T x=0, T y=0, T z=0) : x(x), y(y), z(z) {}",
      "	bool operator<(R p) const {",
      "		return tie(x, y, z) < tie(p.x, p.y, p.z); }",
      "	bool operator==(R p) const {",
      "		return tie(x, y, z) == tie(p.x, p.y, p.z); }",
      "	P operator+(R p) const { return P(x+p.x, y+p.y, z+p.z); }",
      "	P operator-(R p) const { return P(x-p.x, y-p.y, z-p.z); }",
      "	P operator*(T d) const { return P(x*d, y*d, z*d); }",
      "	P operator/(T d) const { return P(x/d, y/d, z/d); }",
      "	T dot(R p) const { return x*p.x + y*p.y + z*p.z; }",
      "	P cross(R p) const {",
      "		return P(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x);",
      "	}",
      "	T dist2() const { return x*x + y*y + z*z; }",
      "	double dist() const { return sqrt((double)dist2()); }",
      "	//Azimuthal angle (longitude) to x-axis in interval [-pi, pi]",
      "	double phi() const { return atan2(y, x); } ",
      "	//Zenith angle (latitude) to the z-axis in interval [0, pi]",
      "	double theta() const { return atan2(sqrt(x*x+y*y),z); }",
      "	P unit() const { return *this/(T)dist(); } //makes dist()=1",
      "	//returns unit vector normal to *this and p",
      "	P normal(P p) const { return cross(p).unit(); }",
      "	//returns point rotated 'angle' radians ccw around axis",
      "	P rotate(double angle, P axis) const {",
      "		double s = sin(angle), c = cos(angle); P u = axis.unit();",
      "		return u*dot(u)*(1-c) + (*this)*c - cross(u)*s;",
      "	}",
      "};",
      ""
    ],
    "description": "Point3D"
  },
  "PointInsideHall": {
    "prefix": "pointinhall",
    "body": [
      "bool inHull(const vector<P>& l, P p, bool strict = true) {",
      "	int a = 1, b = sz(l) - 1, r = !strict;",
      "	if (sz(l) < 3) return r && onSegment(l[0], l.back(), p);",
      "	if (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);",
      "	if (sideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p)<= -r)",
      "		return false;",
      "	while (abs(a - b) > 1) {",
      "		int c = (a + b) / 2;",
      "		(sideOf(l[0], l[c], p) > 0 ? b : a) = c;",
      "	}",
      "	return sgn(l[a].cross(l[b], p)) < r;",
      "}",
      ""
    ],
    "description": "PointInsideHall"
  },
  "PolygonArea": {
    "prefix": "area",
    "body": [
      "template<class T>",
      "T polygonArea2(vector<Point<T>>& v) {",
      "	T a = v.back().cross(v[0]);",
      "	rep(i,0,sz(v)-1) a += v[i].cross(v[i+1]);",
      "	return a;",
      "}",
      ""
    ],
    "description": "PolygonArea"
  },
  "PolygonCenter": {
    "prefix": "polycenter",
    "body": [
      "typedef Point<double> P;",
      "P polygonCenter(const vector<P>& v) {",
      "	P res(0, 0); double A = 0;",
      "	for (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {",
      "		res = res + (v[i] + v[j]) * v[j].cross(v[i]);",
      "		A += v[j].cross(v[i]);",
      "	}",
      "	return res / A / 3;",
      "}",
      ""
    ],
    "description": "PolygonCenter"
  },
  "SegmentIntersection": {
    "prefix": "seginter",
    "body": [
      "template<class P> vector<P> segInter(P a, P b, P c, P d) {",
      "	auto oa = c.cross(d, a), ob = c.cross(d, b),",
      "	     oc = a.cross(b, c), od = a.cross(b, d);",
      "	// Checks if intersection is single non-endpoint point.",
      "	if (sgn(oa) * sgn(ob) < 0 && sgn(oc) * sgn(od) < 0)",
      "		return {(a * ob - b * oa) / (ob - oa)};",
      "	set<P> s;",
      "	if (onSegment(c, d, a)) s.insert(a);",
      "	if (onSegment(c, d, b)) s.insert(b);",
      "	if (onSegment(a, b, c)) s.insert(c);",
      "	if (onSegment(a, b, d)) s.insert(d);",
      "	return {all(s)};",
      "}"
    ],
    "description": "SegmentIntersection"
  },
  "CircumCirle": {
    "prefix": "cc",
    "body": [
      "typedef Point<double> P;",
      "double ccRadius(const P& A, const P& B, const P& C) {",
      "	return (B-A).dist()*(C-B).dist()*(A-C).dist()/",
      "			abs((B-A).cross(C-A))/2;",
      "}",
      "P ccCenter(const P& A, const P& B, const P& C) {",
      "	P b = C-A, c = B-A;",
      "	return A + (b*c.dist2()-c*b.dist2()).perp()/b.cross(c)/2;",
      "}",
      ""
    ],
    "description": "CircumCirle"
  },
  "LineDistace": {
    "prefix": "linepd",
    "body": [
      "template<class P>",
      "double lineDist(const P& a, const P& b, const P& p) {",
      "	return (double)(b-a).cross(p-a)/(b-a).dist();",
      "}",
      ""
    ],
    "description": "LineDistace"
  }
}
